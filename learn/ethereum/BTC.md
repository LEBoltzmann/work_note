# 区块链与比特币
本文根据肖臻北京大学公开课、比特币白皮书等资料。重新总结关于区块链和比特币的知识。
[TOC]

# 比特币的密码学原理
## 加密哈希函数
### 性质
哈希碰撞（Hash collision）是一个哈希函数的性质，两个输入可能会在哈希函数的映射之后映射到一个值。因为输入空间是远大于输出空间的。
$$
\text{for some } x ,\ \exists y\quad H(x) = H(y)
$$
但是我们认为很难通简便算法对任意x得到y，很难人为创造哈希碰撞。我们认为这种哈希函数是抗碰撞的（collision resistance）。加密哈希函数还有一个功能：
$$
x \rightarrow H(x) \quad x\nleftarrow H(x)
$$
即仍然只能通过暴力破解获得原文。比特币要求的哈希函数还有第三个性质：
$$
\exists S\in X, H(x) \text{ where  } x\in S \text{ 更容易符合条件f}
$$
即对于任意条件我们无法时间知道某个范围的定义域更容易得到某种条件的哈希值，这种性质称为puzzle friendly。这种性质保证了挖矿是没有捷径的。

哈希函数也要满足difficult to solve and easy to verify，来保证得到的结果可以很容易的被验证。比特币使用的函数是SHA256，它满足这三个性质。

## 账户
比特币使用公私钥来创建账户公钥用于确认钱包地址，私钥用于确定身份，储存在本地。在转账时需要用户使用私钥签名来确定身份。
### 好的随机源
生成账户的时候要有好的随机源，为了防止私钥泄漏

？随机源如何产生

# 比特币数据结构
## 哈希指针
比特币通过计算块头的哈希值来定位块，称为哈希指针。整个区块链通过哈希指针相连。
### tamper-evident log
哈希指针的作用不仅是构成相连的区块链，哈希指针因为包含整个块的信息所以可以防止对区块链信息的篡改。改变任何一个区块的内容会导致后面所有区块数据改变。
## merkle tree
merkle tree是通过哈希指针连接的类似二叉树的结构。每一个节点的哈希值由它下面的两个节点的哈希计算出。只要我们有merkle tree的根哈希我们就可以确定任何对merkle tree的修改。
### merkle proof
当我们想确定某个交易的时候，只要找到对应merkle tree的位置，从这个位置倒推每一层的哈希值知道得到根节点哈希。这样只要储存merkle tree中相关的节点的哈希值就可以确定交易确实在以前的区块中。这样就使轻节点也可以验证交易。这种证明叫proof of membership。
### non-member proof
想要证明merkle tree中是否不包含某一个交易，可以使用一个根据哈希排序好的merkle tree。这样可以通过logN复杂度推断某个交易是否存在。但是比特币并不需要查询non-member所以并没有这种设计。
# 协议
## 交易结构
每一次交易都要回溯过往的交易，如果这个交易确实存在并没有被花费则交易可以进行。为了验证交易是否是属于花费者的，需要这些数据验证：
* 花费者的私钥签名
* 上一个交易中花费者的公钥哈希（地址）

通过这两个数据可以验证一个交易的成立。所以一个完整的交易信息需要包括：
* 上一个交易的地址
* 来源的私钥签名
* 交易数量
* 转账去处的地址

## 区块结构
区块头包括的数据：
* 版本信息
* 前一个区块头哈希
* merkle root hash
* time，块的时间戳
* target，POW的目标
* nonce，改变随机值来满足要求

区块头的信息就可以保证区块信息不被篡改。交易信息储存在区块体中。

## 分布式共识
区块链能得到所有节点的共识称为分布式共识。在分布式系统理论中有FLP理论1，说明了异步网络中是无法达成共识的。另一个理论是CAP理论，以下三个性质无法全部实现。
* Consistency
* Availability
* Partition tolerance

可见[拜占庭问题](../math/Byzantium.md)

## 比特币共识
### 投票的问题
异步网络中投票本身面临着网络延迟和节点沉默的问题，导致面向所有人的投票不现实。并且也面临着女巫攻击，即一个账户伪装成多个节点投票。

### POW
比特币使用POW来规避这些问题，通过计算复杂问题添加块来决定应当添加哪个块,这种方式可以避免女巫攻击。比特币遵循最长合法链原则，新的区块应该扩展最长的链。通过在区块链中间插入分叉来攻击（双花，回滚）叫做分叉攻击。

POW一方面保证只有那些网络好的节点才有必要参与共识，而那些不太好的节点不去参与共识也没什么损失（否则很容易在竞争区块/同时出块的临时分叉的时候失败，另一方面由于回滚区块需要大量算力，不参与共识也不会过于影响节点的权益）。这就是一种trade off来规避CAP理论中提出的问题。另一方面由于参与共识需要付出算力的代价，也在限制攻击节点的行为。比如它们没有足够的理由去破坏整个节点，POW通过引入更多经济、博弈论的因素来给解决拜占庭问题添加前提条件来简化问题。

比特币同时通过动态调整挖矿难度来稳定出块时间，减少好节点分叉风险。类似于PBFT中设置响应时间，让同一个共识能接收尽可能多好节点的参与。

## 分叉
### state fork
当对比特币目前状态有分歧的时候产生的临时分叉。
* forking attack分叉攻击，但是是故意产生分歧。也叫deliberate fork。
### protocol fork
协议分叉，当比特币升级协议的时候有些节点可能对协议意见不同产生分叉。
* hard fork：新旧节点对比特币协议产生分歧。比如：
    * block size limit：由于比特币区块的大小限制，区块链处理交易的效率有限。如果有些节点更新软件更改块大小而某些节点没有更新，那么大区块不会被旧协议认可就会造成硬分叉。
* soft fork：有些更新造成旧节点认可新节点但新节点不认可旧节点。这种情况旧节点也会切换到最长链上。所以旧节点也会更新软件，只会是临时分叉。
    * 比特币历史上的软分叉例子是P2SH的更新。

~~一个有趣的历史是硬分叉旧币可以在两个链上分别花费（发生在以前比特币BTC、BCH与以太坊ETH、ETC硬分叉上。但以太坊使用账户记账模式所以在ETH上花费会造成ETC上也花费，这个bug在后续被修复了。）~~

## 安全性
### 恶意节点的可能攻击
* 恶意节点无法偷取比特币，因为他无法伪造签名。诚实的节点不会承认这个交易。
* 双花：恶意节点无法通过延续链来实现双花，因为同一个链上同一个交易已经不是UTXO了。双花要通过分叉链攻击来实现双花。可以等待多个区块确认来避免这种攻击，这样会让分叉链攻击的成本更大。比特币协议中要等6个确认才认为前面的交易是不能篡改的。
* 不包含交易：恶意节点可以选择不包含一部分合法交易。
* selfish mining：正常出块是要抢先发布的，selfish mining指挖块的时候不发布，等待长链确认之后再发布实现双花。这种攻击也需要恶意节点占据更多算力成功的机会更高。

# 实现
## UTXO
UTXO(Unspent Transaction Output)未花费输出是用来表示可以花费的比特币的数据结构。
## 交易
区块链有两种模式，一个是通过账户（与日常经验的概念相同），一个是通过UTXO。比特币是使用UTXO来进行交易。

每笔交易包含上一个UTXO和转出的账户。往往每个交易输入和输出的值会有一个差值，作为给出块者的小费。

## 挖矿
### Bernoulli trail
一种拥有二值结果的随机实验。挖矿就是这样的实验，失败的概率远大于成功。伯努利实验的概率密度曲线服从Poisson process。出下一个块的时间的概率密度按指数分布。这揭示过往的挖矿努力并不会增加未来时间出块的期望（指数分布截断仍然是指数分布）。这让高算力的节点并不会比低算力的节点获得压倒性的优势。

### 挖出币的数量
比特币每21W个区块调整出块奖励，每次减半。最后总的发行量会收敛到
$$
21W\times 2\times50 = 2100W
$$
### 节点
#### 全节点
全节点要求：
* 一直在线
* 本地维护完整区块链信息
* 在内存维护UTXO
* 监听交易信息并验证交易合法性
* 决定那些交易会被打包到区块内
* 监听别的矿工挖出的区块，验证其合法性
* 挖矿
    * 决定沿着那条链挖矿
    * 出现等长的分叉的时候需要选择哪一个分叉。

#### 轻节点
* 不用一直在线
* 只保存区块头
* 只保存与自己相关的交易
* 不能验证别人交易的合法性
* 无法检测发布区块的正确性
* 可以验证挖矿难度
* 只能检测哪个是最长链

这其实说明比特币共识的准入是有门槛的，轻节点只有发布交易等部分权力。如果能通过零知识证明等方式让轻节点不因为储存、计算资源的限制而进入共识中会是一个很大的进步。

### 设备
挖矿中只涉及整数计算，所以一般使用GPU计算。为了让算力资源不被浪费也出现了专门挖矿的ASIC（Application Specific Integrated circuit），专门根据某种币设计的只用于挖矿的设备。所以很多币会设计与比特币相似的mining puzzle来吸引有ASIC的用户来挖矿，成为merge mining。同时这种设备也一定程度违背比特币去中心化的初衷，也有人设计Alternative的算法来抵抗使用ASIC挖矿。

### 矿池
矿池由矿主和下面一系列矿工组成。矿主负责主节点指责，矿工只负责计算哈希。这样可以稳定矿工的回报。矿工可以通过线下集成合作挖矿，也可以线上进行分布式计算。
## 比特币脚本
比特币交易中验证交易的合法性使用脚本来实现。主要为了支持多签名交易等更灵活的交易方式。

TODO：细节待补充

## 比特币网络
### application layer、network layer
比特币的应用层是比特币区块链，网络层是一个p2p网络。
### 网络实现
比特币网络的设计目的为简介鲁棒，不以快速为目的。每个节点维护一个peer node，每个节点通过根节点连接进比特币网络，在需要发布交易、收到交易的时候把交易广播给peer node。

## 挖矿难度
比特币的挖矿难度定义是：
$$
H(\text{block header}) \leq target
$$
比特币中使用SHA-256算法来计算哈希。比特币要动态调整难度来让出块时间不会过短。出块时间过短会增加分叉风险，导致共识更难达成。并且当分叉更多51%攻击会更容易。比特币每两周或2016个区块调整难度：
$$
target' = target\times \frac{\text{ectual time}}{\text{expected time}}
$$


