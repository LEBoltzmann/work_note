# zk_snark学习
[TOC]

# 什么是零知识
本笔记主要针对zk_snark算法以及零知识证明。zk-SNARK 是 Zero-knowledge succinct non-interactive arguments of
knowledge，为了解决证明某个声明为真但又不透露任何秘密信息的知识的算法。
## 要素
零知识证明的系统中有一个验证者（verifier）和一个证明者（prover）。verifier知道prover的一个声明是正确的，但又不知道任何隐私信息。过程中的三个性质：
* 完整性：只要陈述是正确的，证明者就可以让验证者确信。
* 可靠性——如果陈述是错误的，那么作弊的证明者就没有办法让验证者相信。
* 零知识——协议的交互仅仅揭露陈述是否正确而不泄漏任何其它的信息。
## 相关算法
zk_SNARKs, zk_STARKs, BulletProofs是主要应用于区块链的零知识证明算法。他们的性能对比：
<img src="./imgs/zk_snark1.png" alt="显示zk算法性能" width="" height="" />
zk_SNARKs性能上来说更好，但需要trust setup
## 大致流程
证明-程序计算-算数电路-多项式-证明多项式
# zk_SNARK多项式原理
## 多项式证明
当我们要验证一个长为10bit的数组，希望它所有值都为1。那么验证者为了得到足够的置信度需要验证更多的bit，并且与数组长度成正比。这就导致长度很长的时候这种方案不可行。

在多项式的情况下，对于d阶的多项式，它最多有d个根。并且对于两个d阶多项式它们相减的结果也最多有d个根。于是我们可以设计这样的算法：
* 验证着选择一个点x
* 验证着把x发送给证明者
* 证明者计算多项式的值并发给验证者
* 验证者对比结果是否相同

由于两个不同的多项式最多有d个交点，所以只要x取值范围足够大那么证明者恰好得到相同值的概率就会小很多。这样就可以通过一次验证得到可靠的结果。
## 多项式零知识证明
上面的方法仍然需要双方互相取得信任，如果多项式的值域不够大的话证明者仍然可以通过猜多项式的值来欺骗验证者。
#### 多项式的因式分解
当我们说一个人知道一个多项式的时候，我们认为他知道这个多项式的所有系数。比如对于$c_nx^n + \dots + c_2x^2 + c_1x^1$，证明者声称他知道$\{c_i\}$。当一个证明者声明他知道一个d阶多项式，并且这个多项式有一系列零根$\{x_j\}$。根据因式分解，我们可以找到一个多项式$t(x) = \Pi_{i = 0}^j (x - x_j)$，并且证明者可以通过这个$t(x)$计算$h(x) = p(x) / t(x)$。通过这个思想，我们可以构造新的证明流程：
* 验证者选取r，计算$t = t(r)$，将r发给证明者。
* 证明者计算得到$h(x) = p(x)/t(x)$，计算$h = h(r)$与$p = p(r)$并将p、r发给验证者。
* 验证者验证是否$p = h\cdot t$

这个方案可以实现零知识，但是存在漏洞：
* 验证者知道$t(x)$的情况下（因为是他自己声称的），于是可以随意伪造p、h来满足条件。
* 如果证明者不能任意选取p、h，证明者也可以先构造$h(x)$再计算$p = h\cdot t$
* 如果证明者一定要先选取一个$p(x)$，也无法证明证明者的多项式确实是d阶。

#### 模糊计算
为了避免证明者获得$r$和$t(r)$的值我们通过加密让证明者在不知道r值的情况下给出多项式的值。

我们选择使用模幂来加密r值。模幂有一些特性可以保证证明者在不知道r值的情况下可以计算p、h但是无法得知t，也无法通过$t(x)$生成$h(x)$和$p(x)$来作弊：
$$
c^x\bmod p \cdot c^y\bmod p = c^{x+y}\bmod p\\
\frac{ c^x\bmod p  }{c^y\bmod p} = c^{x-y}\bmod p\\
c^x\bmod p \cdot c^y\bmod p \neq c^{xy}\bmod p
$$

实际上被加密的两个数值的乘法无法从已经知道的加密数值得出（第三行）这就使我们的加密方法成为可能。

如何加密多项式：我们通过如下方法加密r：
$$
E_i = g^{r^i}\bmod p
$$
其中g和p构成循环群。接下来证明者就可以通过$E_i$来算得p、h。具体流程如下：
* 验证者：
    * 随机挑选r并计算$E_i$
	* 计算$t(r)$
	* 发送$E_i$给证明者
* 证明者：
    * 计算多项式$h(x) = \frac{p(x)}{t(x)}$
    * 计算：$p = \Pi_{i = 0}^d E_i^{ c_i }$，h同理。
	* 发送p、h给验证者。
* 验证者
    * 验证是否$p = h^t$

这样就解决了上一次验证算法的漏洞。但接下来还有一个问题，证明者可以通过构造h为一个常数，这样通过h和加密后的$t(r)$仍然能得到$p(r) = t(r)^h$。
#### 约束多项式
我们可以通过对加密值偏移来阻止证明者选取随意的值来计算多项式。以离散对数举例：验证者希望证明者以a为底计算幂模，但是我们无法证明证明者确实使用a为底而不是随意选取一个值。那么可以用一下流程：
* 验证者发送一对值$(a, a') = (a,a^{\alpha})$给证明者
* 证明者计算两个值的模幂$(b, b') = (a^c, a'^c)$
* 验证者验证是否$b^{\alpha} = b'$

在这过程中由于离散对数问题证明者都无法获得对方的的$\alpha$和c但是仍然可以证明证明者是以a为底计算。把这个思想运用到多项式证明中：
* 验证者计算$E_i$的同时计算$E_i' = g^{\alpha r^i}$
* 证明者通过E和E'计算p和p‘
* 验证者同时验证$p^\alpha = p'$

因为：
<img src="./imgs/zk_snark2.png" alt="大概证明" width="" height="" />
现在整个协议已经足够健壮，但是验证者仍然能通过证明者给出的信息推算出一个多项式。因为费马小定理：
$$
g^{(p-1)x^{i}} = g^{x^i} \bmod p
$$
所以能观测到的多项式系数取值是有区间的，于是可以通过暴力破解得到一个多项式，虽然与证明者所有的多项式可能不是一个，但是仍然获得来关于证明的信息。

#### 零知识证明
最后我们希望验证者无法获得证明者的知识，仍然可以使用偏移，让证明者通过随机偏移传递值给验证者：
$$
random\ \delta, pass\ ( g^{p(r)} )^{\delta}( g^{p(r)} )^{\delta}( g^{p(r)} )^{\delta}
