# 数学工具
为了避免麻烦和重复把所有数学工具在这里总结
[TOC]
# 树们
## merkle tree
merkle tree也叫哈希树。它的非叶节点都是由它下面连接的两个子节点的哈希计算，叶节点表示某个数据的哈希。见图：

<img src="./imgs/mo_mt1.png" alt="mt图示" width="" height="" />

在某一层的叶节点数量为奇数时会复制最后的叶节点来计算。mt的功能有很多，比特币出现之前经常作为p2p文件下载（如BT）、数据库系统等中用于校验文件完整性、可信性。比如在BT下载时先向可信信源获得mt root并与下载源的文件mt进行校验。

在比特币中mt也保障交易不被篡改，并可以把交易信息打包放入区块头中。同时mt提供了轻量的验证方式使得轻节点也可以在不下载交易数据的情况下校验merkle tree：

<img src="./imgs/mo_mt2.png" alt="" width="" height="" />

如图，为了校验交易0可以向全节点申请路径上的所有mt叶子节点进行验证，复杂度为$O(log(N))$
### 攻击: Second preimage attack

对于mt可以使用重放攻击。因为在叶子节点为奇数的时候要复制最后一个节点，所以体现在叶节点上通过重复最后的一些叶节点可以伪造拥有同样mt root的不同mt。在比特币中使用这样的攻击可以广播拥有同样交易的假mt，来让原本的块不受矿工信任。可以通过在叶节点前面添加0x00前缀，在内部节点前添加0x01前缀来防止这种攻击。

## Trie Tree
又称前缀树、字典树。Trie Tree 除了根节点每个子叶节点都包含一个字符，从根节点到叶节点路上所有的字符构成一个关键字来查询值。通常每个子节点除了包含它代表的字符外还包括一个确认值来表示这个子节点是否也构成一个关键字，如图：

<img src="./imgs/mo_tt1.png" alt="Trie Tree图示" width="" height="" />

### 优缺点
* 查询更快，查询时间复杂度为$O(M)$，取决于查询关键字的长度。与此相对哈希表的查询效率有赖于哈希函数的设计。
* tt中不同关键字不会冲突。
* 只有允许一个关键字关联多个值的时候才会发生类似于哈希碰撞的事情。
* tt不需要计算哈希值，对短关键字的效率更高。
* tt可以根据字典顺序排序关键字。
* *哈希函数设计的好的时候tt查询效率更低*
* *空间消耗比较大*

### 应用
通过定制子节点数据结构可以做到多种功能。比如查询关键字（在子叶节点添加bool值判断是否有此关键字），查询词频（在子叶节点加计数器）。

单词排序，按照字母表排序深度优先遍历tt。

前缀匹配，找到前缀子节点并遍历子节点下单词。

...

## Partricia Tree
压缩前缀树。相对于Trie，如果子节点是唯一的子节点则与父节点合并，更节省空间。

以太坊中就是使用一种Merkle Partricia Trie。

# 以太坊中的编码

MPT中有三种编码：keybytes, Hex, Compact
* keybytes 是key的原生表示。
* Hex为了能插入到16进制的MPT中，要把keybytes表示的一个byte拆成两个分别作为一位Hex编码。并且转换编码后会在最后一位加上一byte的16来标志Hex编码
* 在储存MPT到DB的时候需要把Hex编码换回1byte的编码。有时一个Hex编码可能只有奇数位，所以Compact编码会添加额外前缀：
    * 扩展节点偶数：00
    * 扩展节点奇数：1
    * 叶子节点偶数：20
    * 叶子节点奇数：3

每次转换Compact编码到Hex编码先读取前缀判断奇偶，奇数时可以理解为Hex的第一位编码被填充0000 。
## RLP编码
递归长度前缀（RLP）是以太坊发明的编码方式，用来解决数组和嵌套数组的编码储存问题。编码规则为：
* 如果编码为一个值为[0~127]的单字节，编码为其自身。
* 如果编码的byte数组长度小于等于55，前缀为128加长度。
* 如果编码的byte数组长度大于55，编码的第一个前缀是182加数组长度的编码的长度，然后是数组长度本身的编码，然后是byte数组本身的编码。
* 如果列表长度小于等于55，编码结果是192+列表byte长度，后面接子列表的编码。
* 如果列表长度大于55，编码结果第一位是247加列表长度的编码的长度，后面是列表长度的编码本身，最后依次连接子列表的编码。

同时解码的时候也通过编码前缀递归地选择不同的编码规则来解码。这种编码方式减少了其他储存嵌套数组编码的方式（比如json）带来的大量无用的储存信息的缺点，减少了内存的占用。

# Bloom filter
布隆过滤器是一个可以快速查找一个数据是否在集合中的数据结构。对每一个集合中的数据计算三个哈希并对哈希值对应的值设置为1 。在查询的时候计算三个哈希并查看是否对应值为1就可以确定这个数据有可能在集合中，可以进行进一步的查询。

<img src="./imgs/mo_bf.png" alt="布隆过滤器图示" width="" height="" />

在以太坊中，每个交易会产生一个收据，每个收据里面包含一个布隆过滤器来保存交易信息。在每个区块头中也有一个布隆过滤器来支持快速查找交易是否在区块中。
