# plonk
本文学习plonk。参考：

[zkSnark-Plonk证明系统](https://drive.google.com/file/d/1-wcIHORaRMkcZX32YBey2boUF5d5Aw1t/view?usp=sharing)
[TOC]

# 简介
Plonk系统包括电路系统和多项式系统，怎么构造Plonk标准门以及验证方怎么验证标准门

# 密码学承诺
**Schwartz-Zippel引理**：令P为有限域$\mathbb F$上的多项式$P = F(x_1, x_2, \ldots, x_n)$, 其阶为d。令S为有限域$\mathbb F$的子集，从S中选择随机数$r_1, r_2\ldots, r_n$，则多项式等于零的概率可以忽略，即：

$$
\Pr[P(r_1, r_2, \ldots, r_n) = 0] \leq \frac{d}{|S|}
$$
单变量的情况下，等价于多项式的阶为d，则最多有d个根。

## 承诺的概念
* 承诺：选择x，计算$y=f(x)$，发送y。
* 完全打开，发送原像x。
* 校验$x = f(y)$
* 打开n个随机点。
* 校验n个随机点（概率上验证）

对函数的要求：
* 函数求逆是NP困难的
* 校验简单
* 通常加密货币使用145步代替123步，用概率来保障多项式安全，只有知道多项式的具体解才能打开n个点。可以节省验证复杂度。

## 哈希承诺
* 广播哈希值y
* 完全打开：广播x
* 验证$y = HASH(x)$

## merkle 承诺与Merkle证明
* 承诺：发送Merkle Root
* 打开一个随机点x和x的路径path
* 通过x，root，path校验$root = Merkle(x,path)$

比较低效的做法是直接打开所有点，每个验证来保证每个节点都是对的，但是过于耗费算力。高效的做法是选择检测n个点即可，概率的角度就难以伪造。

Merkle证明就是当我拥有一个交易的私钥并发送交易给别人，通过交易和交易的路径可以计算出一个Root并与以太坊上的root比较。如此证明一个人有花费某token的权力。

## Sigma零知识证明
知道秘密$\omega$，且与公开输入的Q满足$Q=\omega\times G$
* 承诺：选择随机数r，计算发送承诺$A = r\times G$
* 挑战：验证者发送随机数e
* 响应：计算$z = r + e\times\omega$，发送z
* 验证：校验$z\times G = A  + e\times Q$

是一个交互式零知识证明，随机数r遮蔽$\omega$但是仍然能证明z里面包含了关于$\omega$的知识。在实践中可以使用Q和E的哈希值来代替随机挑战e，来保证无交互。

## Pedersen承诺

初始化：椭圆曲线生成元G，H，标量域$F_r$(有限域)，基域$F_q$(椭圆曲线点)
* 承诺：对金额m和随机数r，计算$P = mG+rH$
* 完全打开：发送m和r
* 校验$P=mG+rH$

如果某个账户知道一个以太坊树节点上的余额和随机数r就可以验证承诺取款。这个承诺具有同态性：
* 用户1，2的承诺是$(m_1, r_1),(m_2, r_2)$。两个用户向Alice支付余额并告诉随机数
* 矿工更新Alice的余额承诺$P = P_1+P_2$
* 由于Alice知道$m_1+m_2$和$r_1+r_2$，于是可以验证承诺P

这就使Tornado cash的原理。

### 后门
如果Alice知道G和H之间的离散对数$H = \alpha G$，可以声称自己有大金额：
$$
r' = r-(m'-m)\alpha^{-1}
$$

# 多项式承诺
* 承诺：选择x，计算$y = f(x)$，发送y
* 完全打开x
* 校验：$y = f(x)$
* 打开n个随机点
* 校验n个随机点

## 困难假设
* 离散对数困难假设：椭圆曲线群和生成元$\mathbb G*, G$，已知$G,\alpha G$，任意多项式算出$\alpha$的可能性可忽略。
* t阶强Diffie-Hellman假设：公开$PK = \{\alpha^i G\}_{i = 0}^t \in \mathbb G^{ (t+1) }$。对任意值c能计算出$\frac{1}{\alpha+c}G$的改了吧可以忽略。
* Q阶离散对数假设：公开群$\mathbb G_1 \mathbb G_2$，通过$PK = \{\alpha^i G_1,\alpha^i G_2\}_{i = 0}^Q$可以算出$\alpha$的概率忽略不计。

## 多项式承诺定义
承诺、打开、校验、打开随机点、验证随机点。一般用45步代替23步在概率上保证作弊概率可忽略。
* 初始化群$\mathbb G*$和用于承诺的公钥$PK(\alpha)$，$\alpha$要删除。
* 承诺：输入公钥PK和多项式$\phi(x)$，输出承诺C
* 完全打开：输出多项式$\phi(x)$的系数（数据量太大）
* 校验：验证承诺C与多项式$\phi(x)$一致（验证复杂度高）
* 打开一个随机点i，输出$(i, \phi(i), w_i)$, $w_i = \frac{\phi(x)-\phi(i)}{x-i}$
* 校验随机点

核心思想：以下五个描述等价
* 数据多项式与电路多项式满足运算关系
* 多项式正确
* 几个随机打开点正确
* 商多项式存在
* 验证方计算双线性映射成立。

## 多项式承诺性质
一致性
* 完全打开一致性：能通过完全打开的信息$\phi(x)$和承诺C验证。
* 随机打开点一致性：可以通过$(i, \phi(i), w_i)$和承诺C验证。

**多项式绑定**：对于承诺C，攻击者找到两个不同的多项式$\phi(x),\phi'(x)$使得都能通过C校验的成功概率可忽略。

**随机打开点绑定性**：对于承诺C和位置i攻击者可以输出两个多项式值$\phi(i),\phi'(i)$都能通过校验的概率可忽略。

**保密性**：对于多项式$\phi(x)$，已知$PK,C,(i, \phi(i), w_i)$，任意多项式实践内攻击者不能从其他点得到多项式值$\phi(i')$

从加密的角度讲可以把公钥加密对应到承诺(PK加密)，把数字签名对应到zk的秘密知识(sk)

# KZG多项式承诺
**系统初始化**；对于椭圆曲线双线性群$\mathcal G = (e, \mathbb G, \mathbb G_T), $有毒肥料$\alpha \in_R \mathbb Z_p*$。输出为：
$$
PK = (\mathcal G, G, \alpha G \ldots, \alpha^t G)
$$
setup分为两个集合，一个是PK，一个是VK。两个集合可以是重叠关系。这部分术语叫common reference string CRS，有时也叫struct reference string SRS。
## 1个多项式打开1个随机点
**承诺：**对于多项式$\phi(x) = \sum \phi_j\times x^j$，计算承诺：
$$
C = \phi(\alpha)G = \sum \phi_j  \alpha^j G
$$

**完全打开**：输出多项式系数。

**验证**：验证
$$
C' = \phi(\alpha)G = \sum \phi_j  \alpha^j G = C
$$

在实际上完全打开需要很长的VK（t+1个）和很多的验证计算（计算t+1次椭圆曲线点加）。会消耗大量gas，不值得。

**打开一个随机点**：计算商多项式：
$$
\psi_i(x) = \frac{\phi(x) - \phi(i)}{x-i}
$$
基于商多项式的系数和PK，计算商多项式承诺：
$$
W_i = \psi_i(\alpha)G
$$

输出$(i, \phi(i), W_i)$

**校验一个随机点：**：校验等式：
$$
e(C, G) = e(W_i, \alpha G-i G)\times e(G,G)^{\phi(i)}
$$
承诺$VK = (G, \alpha G)$，这样VK就很小了。

### 关键结论
* 充要条件1：商多项式存在（除得尽）等价于上面的双线性映射成立
* 充要条件2：
    * 商多项式存在等价于$(i, \phi(i))$正确。
    * 商多项式不存在等价于$(i, \phi(i))$错误。

商多项式是KZG的核心，所以除得尽是一个构造承诺的重要性质。
## t个多项式打开1个随机点
设我们的多项式为$\phi_i(x)$，这里承诺计算所有多项式的承诺，记为$C_i$。完全打开仍然是计算不经济的。在打开验证随机点的时候不是一个一个多项式计算而是计算一个聚合的多项式：使用transcript计算随机数$\gamma$
$$
\psi_z(x) = \sum_{i=1}^t \gamma^{t-1} \frac{\phi_i(x)-\phi_i(z)}{x-z}
$$
商多项式承诺为：
$$
W_z = \psi_z(\alpha) G_1
$$
验证时验证：
$$
F = \sum_{i = 1}^t \gamma^{i-1}C_1\quad V = \sum_{i = 1}^t \gamma^{i-1} \phi_i(z) G_1
$$
推导公式成立：
$$
e(F-V, G_2)\times e(-W_z,\alpha G_2-zG_2) = 1
$$

这里区别在于使用了同一个验证$W_z$来代替对每个不等式生成W。这样的好处是节省来证明难度和传输消耗。这里根据S-Z引理认为两个不同的不等式在随机点碰撞的概率可以忽略不计。

## t个多项式打开多个随机点
此时把多项式分为多组计算，比如对于两个点就分为两组。对于多个随机点计算多个$\psi_z(x)$，其他计算相同。接着对两组多项式分别求：
$$
F = F_1-V_1 + r(F_2-V_2)
$$

接着验证：
$$
e(F+z_1\times W_{z_1} + rz_2\times W_{z_2}, G_2)\times e(-W_{z_1}-r\times W_{z_2}, \alpha \times G_2) = 1_{G_T}
$$

## 总结
虽然算法对多多项式和多取值有一定优化但是可以看见KZG多项式越多，打开点越多验证越复杂。后面介绍的Dan Boneh承诺验证复杂度仅与多项式个数有关而与随机打开点数无关。

# Dan Boneh 承诺（Shplonk）
高阶多项式$f$在集合$S\subset\mathbb F$上的函数值等于的姐多项式$r$在$z\in S$上的点函数值$r(z) = f(z)$

## 关键结论
* 对于$|S|$个打开点，两个多项式的值相等：$r(z) = f(z)$
* 目标多项式$Z_S(X) = \Pi_{z\in S}(X-z)$是多项式$f(x)-r(x)$的引子。
* 条件1与条件2等同，$Q(x) = \frac{f(X)-r(X)}{Z_S(X)}$成为商多项式，分母成为目标多项式。

可以看出相对于打开多个点验证多项式，构造商多项式验证复杂度仅和多项式个数有关。
## t打开s个点
**系统初始化**：双线性群为$\mathcal G = (e,\mathbb G_1, \mathbb G_2, \mathbb G_3)$，有毒废料$\alpha$，d+t元组

$<G_1, \alpha G_1, \ldots, \alpha^{d-1}G_1;G_2,\alpha G_2,\ldots,\alpha^tG_2>\in(\mathbb G_1^d,\mathbb G_2^t)$，输出为：
$$
PK = (\mathcal G, G_1, \alpha G_1, \ldots, \alpha^{d-1}G_1;G_2,\alpha G_2,\ldots,\alpha^tG_2)
$$

**多项式承诺**：对每个多项式求，与上面一样。

**打开随机点**
