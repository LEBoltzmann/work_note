# zk_stark
本文学习zk_stark的数学原理，[参考](https://drive.google.com/file/d/1yzC7HEKxTn1Acf5Htt3SLrKM95wj6ksb/view)

[TOC]

# Merkle承诺
对于一个Merkle树每个叶子节点发生变化都会影响根哈希，所以可以通过对某个叶子计算根哈希来进行承诺：

**承诺：** 基于多项式的值生成一个Merkle树root

**打开承诺：** 基于$root(f)$计算随机点c，发送数据$(root(f), c, path(c))$。$path(c)$包含路径上所有兄弟节点的哈希用来验证根哈希。

**验证：** 根据$(c,path(c))$计算根$root'$，与接收到的root进行校验：
$$
root' = root
$$
确保c在树上。

# FRI多项式低阶检测
## 直接测试
对于一个常量函数$f(x) = c$，选取一个固定点$z_1$并计算随机点$w$，检测：
$$
f(z_1) = f(w)
$$
则接受多项式$f(x)$的阶小于1 。对于线性多项式$f(x) = bx +c$，在固定点$z_1,z_2$和计算随机点$w$上，检测三个点在同一条直线上则接受多项式$f(x)$的阶小于2 。d阶以内的多项式$f(x)$需要d个固定点和1个随机点进行检测。

## 组合测试
对于两个d阶以内的多项式$f(x), g(x)$，使用上面的测试需要使用$2d+2$个点。可以计算随机数以及：
$$
h(x) = f(x) + \alpha g(x)
$$
通过$h(x)$构造Merkle树来验证。这样就只需要d+1个点。

## 多项式折半
阶次为d的多项式可以从偶数项和奇数项分别分为两个多项式：
$$
f(x) = \sum_{i = 0}^n a_i x^i
$$
$$
g(x^2) = \sum_{i = 0}^{ \frac{n}{2} } a_{2i} x^{2i}
$$
$$
x h(x^2) = \sum_{i = 0}^{ \frac{n}{2} } a_{2i + 1} x^{2i + 1}
$$
有$f(x) = g(x^2) + x h(x^2)$。gh阶数不同时可以补充0。于是得到了两个分解的多项式$g(x),h(x)$ 阶为 $\frac{d}{2}$。生成随机数$\alpha$可以构造新的 $\frac{d}{2}$ 阶多项式：
$$
f'(x) = g(x) + \alpha h(x)
$$

## FRI原理
FRI（Fast Reed-Solomon Interactive Oracle Proof of Proximity）基于随机数生成改造成非交互式的。通过折半，可以不用$O(d)$而是$O(log(d))$次实现对d阶多项式的阶测试。

**第一步**：

**证明：** 对d阶多项式$f_1(x)$的值进行Merkle承诺，计算$root(f_1)$和随机数：
$$
z = Hash(root(f_1))
$$
计算z的函数值$f_1(z), f_1(-z)$。发送数据：$root(f_1), f_1(z), f_1(-z), path(f_1(z)), path(f_1(-z))$。

**验证：** 通过$root(f_1)$计算z，确定两个点在Merkle数上。

**第二步：** 通过z和$root(f_1)$计算随机值$\alpha_2 = Hash(z, root(f_1))$，折半公式：
$$
f_1(x) = g_1(x^2) + x h_1(x^2)
$$
$$
f_2(x) = g_1(x) + \alpha_2 h_1(x)
$$
计算随机数$-z^2$处的值，发送数据：$root(f_2), f_2(-z^2), path(f_2(z^2)), path(f_2(-z^2))$。其中$f_2(z^2)$可以通过$f_1(z), f_1(-z)$计算。

**验证：** 计算值$\alpha_2, f_2(z^2)$，确定两个值在树上。

**第i步：** 重复折叠验证

**第n=log(d)步：** 在此时$f_{log(d)}(x)$的阶已经到1，所以可以直接测试来完成常量多项式的测试。

## 概率分析
每次计算验证通过随机值来防止伪造并进行非交互，通过每次省缺一个函数值并从上一轮中的函数值计算，这样的计算可以确保函数折叠正确并减少传输值。整个折叠验证过程中在传输path的过程中传输了大量值，因此证明会很大。

在整个流程中作弊成功的可能为$f_i(z) = f_i(-z) = 0$，这样包括折半多项式和折半多项式的两个构成部分都是零。这个概率首先很小，其次因为有多轮折半所以一直能作弊成功的概率指数减少，所以证明方作弊成功的概率可以忽略。

# 斐波那契数列Stark
## 零知识证明
对于一个NP问题F，证明方有公开输入X和保密输入Y，公开输入Z。证明：
$$
F(X,Y) = Z
$$
则验证方接受该事实。

## 斐波那契数列
对于输入X，Y，计算Z为第1000个斐波那契数列值，认为这样的$F(X,Y) = Z$是NP问题。对于这个问题可以构造一个表格，例子：

<img src="./imgs/zk_stark1.png" alt="trace示意图" width="" height="" />

对于这个迹有转换约束：
$$
T_{i+1, 0} = T_{i, 1} \quad T_{i+1, 1} = T_{i, 0} + T_{i, 1}
$$
和边界约束：
$$
T_{0,0} = X\quad T_{1000, 1} = Z
$$
## 迹多项式
通过迹中的寄存器$T_{n,0}, T_{n, 1}$的取值可以通过FFT构造处多项式表达。于是可以构造从斐波那契数列到多项式约束的等价转化：
$$
Q(x) = P_1(i+1) - (P_0(i) + P_1(i)) = 0, i = 0, \ldots 999
$$
多项式值等于零，可以构造商多项式：
$$
R(x) = \Pi_{i}^{999} (x-i)
$$
$$
C(x) = \frac{Q(x)}{R(x)}
$$
是一个常量多项式。这个商多项式是1阶的，可以通过构造更复杂的斐波那契数列来构造比迹的阶次更高的商多项式。比如三元乘法斐波那契，四元乘法斐波那契。

在得到转换约束商多项式和边界约束商多项式之后，就可以通过证明知道商多项式来证明知道约束，接着知道秘密值满足斐波那契数列要求。

## FRI原理
在构造出需要的多项式之后通过计算随机数构造多项式：
$$
C(x) = \alpha_0\times C_0(x) + \alpha_1\times C_1(x) + \alpha_2\times C_2(x)+ \alpha_3\times C_3(x)
$$
对$C(x)$进行折半验证就等价于验证了秘密。回顾一下KZG可以发现这里对待商多项式只是处理的方法不同，KZG使用基于有毒废料的CRS，FRI使用大量Hash和Merkle承诺。所以虽然不需要trust setup但是证明变得巨长。

# zkStark协议
## 算数化


