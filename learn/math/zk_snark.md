# zk_snark学习
[TOC]

# 什么是零知识
本笔记主要针对zk_snark算法以及零知识证明。zk-SNARK 是 Zero-knowledge succinct non-interactive arguments of
knowledge，为了解决证明某个声明为真但又不透露任何秘密信息的知识的算法。
## 要素
零知识证明的系统中有一个验证者（verifier）和一个证明者（prover）。verifier知道prover的一个声明是正确的，但又不知道任何隐私信息。过程中的三个性质：
* 完整性：只要陈述是正确的，证明者就可以让验证者确信。
* 可靠性——如果陈述是错误的，那么作弊的证明者就没有办法让验证者相信。
* 零知识——协议的交互仅仅揭露陈述是否正确而不泄漏任何其它的信息。
## 相关算法
zk_SNARKs, zk_STARKs, BulletProofs是主要应用于区块链的零知识证明算法。他们的性能对比：
<img src="./imgs/zk_snark1.png" alt="显示zk算法性能" width="" height="" />
zk_SNARKs性能上来说更好，但需要trust setup
## 大致流程
证明-程序计算-算数电路-多项式-证明多项式
# zk_SNARK多项式原理
## 多项式证明
当我们要验证一个长为10bit的数组，希望它所有值都为1。那么验证者为了得到足够的置信度需要验证更多的bit，并且与数组长度成正比。这就导致长度很长的时候这种方案不可行。

在多项式的情况下，对于d阶的多项式，它最多有d个根。并且对于两个d阶多项式它们相减的结果也最多有d个根。于是我们可以设计这样的算法：
* 验证着选择一个点x
* 验证着把x发送给证明者
* 证明者计算多项式的值并发给验证者
* 验证者对比结果是否相同

由于两个不同的多项式最多有d个交点，所以只要x取值范围足够大那么证明者恰好得到相同值的概率就会小很多。这样就可以通过一次验证得到可靠的结果。
## 多项式零知识证明
上面的方法仍然需要双方互相取得信任，如果多项式的值域不够大的话证明者仍然可以通过猜多项式的值来欺骗验证者。
#### 多项式的因式分解
当我们说一个人知道一个多项式的时候，我们认为他知道这个多项式的所有系数。比如对于$c_nx^n + \dots + c_2x^2 + c_1x^1$，证明者声称他知道$\{c_i\}$。当一个证明者声明他知道一个d阶多项式，并且这个多项式有一系列零根$\{x_j\}$。根据因式分解，我们可以找到一个多项式$t(x) = \Pi_{i = 0}^j (x - x_j)$，并且证明者可以通过这个$t(x)$计算$h(x) = p(x) / t(x)$。通过这个思想，我们可以构造新的证明流程：
* 验证者选取r，计算$t = t(r)$，将r发给证明者。
* 证明者计算得到$h(x) = p(x)/t(x)$，计算$h = h(r)$与$p = p(r)$并将p、r发给验证者。
* 验证者验证是否$p = h\cdot t$

这个方案可以实现零知识，但是存在漏洞：
* 验证者知道$t(x)$的情况下（因为是他自己声称的），于是可以随意伪造p、h来满足条件。
* 如果证明者不能任意选取p、h，证明者也可以先构造$h(x)$再计算$p = h\cdot t$
* 如果证明者一定要先选取一个$p(x)$，也无法证明证明者的多项式确实是d阶。

#### 模糊计算
为了避免证明者获得$r$和$t(r)$的值我们通过加密让证明者在不知道r值的情况下给出多项式的值。

我们选择使用模幂来加密r值。模幂有一些特性可以保证证明者在不知道r值的情况下可以计算p、h但是无法得知t，也无法通过$t(x)$生成$h(x)$和$p(x)$来作弊：
$$
c^x\bmod p \cdot c^y\bmod p = c^{x+y}\bmod p
$$
$$
\frac{ c^x\bmod p  }{c^y\bmod p} = c^{x-y}\bmod p
$$
$$
c^x\bmod p \cdot c^y\bmod p \neq c^{xy}\bmod p
$$

实际上被加密的两个数值的乘法无法从已经知道的加密数值得出（第三行）这就使我们的加密方法成为可能。

如何加密多项式：我们通过如下方法加密r：
$$
E_i = g^{r^i}\bmod p
$$
其中g和p构成循环群。接下来证明者就可以通过$E_i$来算得p、h。具体流程如下：
* 验证者：
    * 随机挑选r并计算$E_i$
	* 计算$t(r)$
	* 发送$E_i$给证明者
* 证明者：
    * 计算多项式$h(x) = \frac{p(x)}{t(x)}$
    * 计算：$p = \Pi_{i = 0}^d E_i^{ c_i }$，h同理。
	* 发送p、h给验证者。
* 验证者
    * 验证是否$p = h^t$

这样就解决了上一次验证算法的漏洞。但接下来还有一个问题，证明者可以通过构造h为一个常数，这样通过h和加密后的$t(r)$仍然能得到$p(r) = t(r)^h$。
#### 约束多项式
我们可以通过对加密值偏移来阻止证明者选取随意的值来计算多项式。以离散对数举例：验证者希望证明者以a为底计算幂模，但是我们无法证明证明者确实使用a为底而不是随意选取一个值。那么可以用一下流程：
* 验证者发送一对值$(a, a') = (a,a^{\alpha})$给证明者
* 证明者计算两个值的模幂$(b, b') = (a^c, a'^c)$
* 验证者验证是否$b^{\alpha} = b'$

在这过程中由于离散对数问题证明者都无法获得对方的的$\alpha$和c但是仍然可以证明证明者是以a为底计算。把这个思想运用到多项式证明中：
* 验证者计算$E_i$的同时计算$E_i' = g^{\alpha r^i}$
* 证明者通过E和E'计算p和p‘
* 验证者同时验证$p^\alpha = p'$

因为：
<img src="./imgs/zk_snark2.png" alt="大概证明" width="" height="" />
现在整个协议已经足够健壮，但是验证者仍然能通过证明者给出的信息推算出一个多项式。因为费马小定理：
$$
g^{(p-1)x^{i}} = g^{x^i} \bmod p
$$
所以能观测到的多项式系数取值是有区间的，于是可以通过暴力破解得到一个多项式，虽然与证明者所有的多项式可能不是一个，但是仍然获得来关于证明的信息。

#### 零知识证明
最后我们希望验证者无法获得证明者的知识，仍然可以使用偏移，让证明者通过随机偏移传递值给验证者：
$$
random\ \delta, pass\ ( g^{p(r)} )^{\delta}( g^{p(r)} )^{\delta}( g^{p(r)} )^{\delta}
$$
这样可以通过离散对数问题来避免验证者知道证明者的多项式。

## 非交互多项式零知识证明
上面已经定义了一个交互式的零知识证明，但是这证明仍然无法让其他人信服，因为双方可以通过串通来伪造r和$\delta$。我们希望有一个公开可信可以复用的
#### 加密值的相乘
配对操作（双线性映射）是一种数学结构，对于两个加密值$g^a$和$g^b$可以把加密值a，b确定的映射到另一组数据上
$$
e(g^a g^b) = e(g, g)^{ab}
$$
对于生成元g认为a、b为线性项（不恰当的线性函数类比就是两个向量内积，向量是生成元，向量上乘以不同的值会把结果乘以同样的值）：
$$
e(g^a, g^b) = e(g^b, g^a) = e(g^{ab}, g) = e(g, g^b)^a = e(g, g)^{ab}
$$
配对的结果是在目标集的不同生成元上，把这个生成元设为p，可以写作$e(g^a, g^b) = p^{ab}$。因为p具有同态加密的特性所以把乘法配对的结果加在一起：
$$
p^a\times p^b = p^{a+b}
$$
#### 可信任参与方的setup
通过双线性映射的方式，可以重新组织公开参数，并在生成参数之后销毁原数值，来保证意外泄露。这些用以zk的参数称为common reference string(CRS)。
* 验证者生成$\{g^{r^i}, g^{\alpha r^i}\}$给证明者，自己使用$\{g^{t(r)}, g^\alpha \}$做验证。
* 证明者仍然生成偏移后的$g^{p(r)}$, $g^{h(r)}$, $g^{p'(r)}$
* 验证者在双线性目标域中验证多项式与偏移值：
$$
e(g^{p(r)}, g^1) = e(g^{h(r)}, g^{t(r)})
$$
$$
e(g^{p(r)}, g^\alpha) = e(g^{p'(r)}, g^1)
$$
这一操作的目的是在删除r与$\alpha$的情况下仍然能信任证明。

#### 信任任意一个参与者
对于其他参与方仍然需要信任参与者是否真的删除了相关参数，这一点没法证明（proof of ignorance是一个正在积极研究的领域）。

一个解决办法是通过多个人共同生成一个CRS（多方计算）。假如在有三个人参与的场景：
* 首先，A选取随机数$r_a$, $\alpha_a$生成一个CRS：$\{g^{r_a^i}, g^{\alpha_a}, g^{\alpha_a r_a^i}\}$。
* 对于下一个人B，选取随机数$r_b$, $\alpha_b$，使用同态加密加密A生成的CRS：$\{( g^{r_a^i} )^{s_b}, ( g^{\alpha_a} )^{\alpha_b}, ( g^{\alpha_a r_a^i} )^{\alpha_bs_b}\}$
* 对于第三个人也一样

最终我们得到了一个融合所有人所选取的随机数的CRS，除非所有人合谋否则不能得到随机值。这里还有一个问题就是攻击者在中间使用不同的随机值计算来扰乱CRS生成，使用双线性可以验证B的CRS是否由A的CRS得来。

验证每一个幂值是否由同一个r得出：
$$
e(g^{r^i}, g)=e(g^{r^{i-1}}, g^r)
$$
验证偏移值是否正确：
$$
e(g^{r^i}, g^\alpha)=e(g^{\alpha r^{i}}, g)
$$
这样的验证之后还存在问题，最后一个参与者可以不使用前面的CRS而是自己直接计算一个合理的CRS。所以要求所有参与者单独发出自己的加密数值：$\{g^{r_b^i}, g^{\alpha_b}, g^{\alpha_b r_b^i}\}$。这样就可以验证：
* $e(g^{r_{ab}^i}, g) = e(g^{r_a^i}, g^{r_b^i})$
* $e(g^{\alpha_{ab}}, g) = e(g^{\alpha_a}, g^{\alpha_b})$
* $e(g^{\alpha_{ab}r_{ab}^i}, g) = e(g^{\alpha_a r_a^i}, g^{\alpha_b r_b^i})$

## 结论
我们用 zk-SNARK 协议来解决多项式问题的知识，不过这是一个有局
限的例子。因为大家可以说 prover 只要用另外一个有界的多项式去乘以
t(x) 就可以很容易得构造出一个能够通过测试的多项式 p(x) ，并且这种结
构也是有效的。

验证者知道证明者有一个有效的多项式，但是并不知道是哪一个。我
们可以利用增加额外的证明来证明证明者知道的多项式有某些特定的性质，
如额外证明: 被多个多项式整除，是某个多项式的平方。做好有一个通用的
方式能来支持无数的应用。

这部分逐步地解决了从加密到无知识的一系列问题，下面的部分介绍怎么构造通用的zk-SNARK。

# 从程序到多项式的构造

